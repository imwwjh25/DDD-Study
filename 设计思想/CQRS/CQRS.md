# CQRS 原则详解

CQRS 全称**Command Query Responsibility Segregation**，即**命令查询职责分离**，是由 Greg Young 在 CQS（命令查询分离）原则基础上提出的架构设计模式。其核心思想是：将系统中 ** 改变系统状态的命令（写操作）**与**读取数据的查询（读操作）** 进行职责完全拆分，使用各自独立的模型、逻辑甚至存储来处理，彻底解决传统 CRUD 架构中同一模型兼顾读写带来的耦合与性能瓶颈问题。

## 一、核心源头：CQS 与 CQRS 的区别

CQRS 脱胎于 Bertrand Meyer 提出的**CQS（Command Query Separation，命令查询分离）** 基础原则，二者核心差异如下：

| 特性     | CQS 原则                                                     | CQRS 模式                                                    |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 分离粒度 | 代码方法级别                                                 | 系统架构级别                                                 |
| 核心规则 | 一个方法要么是命令（改状态），要么是查询（返数据），不能两者兼有 | 不仅拆分方法，更拆分读写的完整模型、服务、甚至存储，读写完全解耦 |
| 适用范围 | 代码规范，面向单个对象 / 方法                                | 架构设计，面向整个系统 / 服务                                |

## 二、核心概念：命令 vs 查询

CQRS 将系统所有操作严格划分为两类，二者边界清晰、职责互斥：

### 1. 命令（Command）

- 核心定位：**写操作**，负责改变系统状态，是对业务行为的抽象（而非简单的数据更新）
- 核心特性：有业务副作用、需事务保障、聚焦数据一致性与业务规则校验
- 返回规则：仅返回操作执行结果（成功 / 失败、异常信息、生成的 ID 等），**不返回业务数据**
- 示例：创建订单、支付订单、取消订单等业务行为

### 2. 查询（Query）

- 核心定位：**读操作**，负责获取系统状态，不做任何数据修改
- 核心特性：无副作用、幂等（多次调用结果一致）、可缓存、聚焦查询效率与数据展示
- 返回规则：返回业务所需的数据集，**绝对不修改系统状态**
- 示例：查询订单详情、获取用户订单列表、订单数据统计等

## 三、CQRS 四大核心原则

1. **职责互斥原则**

   一个操作只能是命令或查询，绝不能同时兼具读写能力，严格遵循 “问不改，改不问”，杜绝一个方法既修改数据又返回业务数据的情况。



2. **无副作用原则**

   查询操作必须完全无副作用，多次调用不会改变系统状态，不触发任何业务规则；所有状态变更、业务规则执行，必须全部收敛到命令侧处理。



3. **模型独立原则**

   读写使用完全独立的领域模型，互不绑定：



- 写模型（命令侧）：聚焦业务规则、领域逻辑、事务一致性，严格遵循业务约束，通常与 DDD 的聚合根设计深度结合；
- 读模型（查询侧）：聚焦查询效率、数据展示，按需定制扁平化 DTO / 视图，可做反范式设计，无需遵循写模型的领域约束。



4. **关注点分离原则**

   读写的业务逻辑、技术实现、部署扩容、权限管控完全解耦，可独立演进、独立优化，互不干扰。



## 四、常见实现方式

CQRS 没有固定的技术实现，可根据业务复杂度选择不同的落地方式：

1. **轻量级 CQRS**

   仅在应用层拆分命令与查询的接口、处理逻辑，共享同一个数据库。适合中小项目，复杂度低，兼顾 CQRS 的解耦优势，避免过度设计。



2. **进阶型 CQRS**

   读写使用完全独立的存储（写库 + 读库），通过事件驱动、消息队列等方式实现数据同步，常与事件溯源（Event Sourcing）、DDD 领域驱动设计结合。适合高并发、复杂业务的分布式系统，可实现读写极致的性能优化与独立扩容。



## 五、核心优缺点

### 优点

- **架构解耦，复杂度隔离**：读写逻辑互不干扰，写模型专注业务规则，读模型专注查询效率，避免代码臃肿，大幅提升可维护性。
- **极致的性能优化空间**：读写可分别做针对性优化，比如写库优化事务与一致性，读库做索引、反范式、缓存、分库分表，完美应对高并发读写场景。
- **超强的可扩展性**：读写服务可独立部署、独立扩容，轻松应对读写流量差异巨大的业务（如电商商品读多写少，交易系统写多读少）。
- **精细的安全管控**：可针对命令和查询分别做权限控制，读写的权限粒度、校验规则完全分开，降低安全风险。
- **适配复杂业务**：完美适配 DDD 领域驱动设计，复杂业务中，写模型的聚合设计无需为查询妥协，能更好地落地领域逻辑。

### 缺点

- **系统复杂度提升**：需要维护两套模型，进阶版还要维护数据同步链路，增加开发、测试、运维成本。
- **数据一致性挑战**：读写分离场景下，写库到读库的数据同步存在延迟，只能保证最终一致性，需要业务层面处理数据延迟带来的问题。
- **落地门槛高**：团队需要理解 CQRS 的核心思想，避免滥用，简单 CRUD 系统用 CQRS 会造成过度设计，得不偿失。
- **问题排查难度增加**：链路变长，数据同步环节多，出现问题时排查定位更复杂。

## 六、适用与不适用场景

### 适用场景

- 业务领域复杂，读写的业务逻辑、需求差异巨大，有丰富领域规则的系统（如 DDD 架构的系统）；
- 读写流量差异极度不均的系统，比如读多写少的内容平台、电商商品系统，或写多读少的交易、风控系统；
- 需要对读写分别做独立的性能优化、安全管控、扩容部署的分布式系统；
- 配合事件溯源、事件驱动架构的系统。

### 不适用场景

- 简单 CRUD 业务，业务逻辑简单，读写逻辑基本一致的系统（如简单的后台管理系统）；
- 对数据强一致性要求极高，无法接受最终一致性的核心交易场景；
- 团队规模小、技术能力不足，无法承担架构复杂度的项目。

## 七、常见误区纠正

1. **误区 1：CQRS 就是数据库读写分离**

   纠正：数据库读写分离是存储层面的主从复制优化，应用层仍使用同一套模型；而 CQRS 是架构层面的职责与模型拆分，二者没有必然绑定关系，哪怕共享同一个数据库，只要读写模型、逻辑分离，就是符合 CQRS 原则的。



2. **误区 2：CQRS 必须分库分表、必须用事件溯源**

   纠正：轻量级 CQRS 可以共享同一个数据库，事件溯源只是 CQRS 的常见搭配，不是必须项。



3. **误区 3：CQRS 适合所有项目**

   纠正：CQRS 是为了解决复杂业务、高并发读写的痛点，简单业务用它会过度设计，反而增加开发维护成本。