# 一句话核心

高层业务，不要直接依赖底层细节。

大家都依赖「抽象」。

------

# 用电商场景秒懂

你写一个 **订单结算** 功能：

- 订单结算 = 高层
- 优惠券、满减、折扣 = 底层细节

### 错误写法（不依赖倒置）

订单结算 **直接 new 优惠券**：





```
public class OrderService {
    // 高层直接依赖底层具体类
    private CouponDiscount coupon = new CouponDiscount();
}
```

问题：

- 明天要换成 **满减**
- 你必须 **改 OrderService 代码**
- 高层被底层绑死了

这就叫：

**高层依赖底层 → 耦合死了 → 改不动**

------

# 正确写法（依赖倒置）

1. 先搞一个 **抽象接口**

```
public interface Discount {
    double calc(double amount);
}
```

1. 优惠券、满减 **都去实现这个接口**

```
public class Coupon implements Discount {}
public class FullReduce implements Discount {}
```

1. 高层 **只依赖接口**，不依赖具体类

```
public class OrderService {
    // 只依赖抽象！不依赖任何具体优惠
    private Discount discount;

    // 从外面传进来（注入）
    public OrderService(Discount discount) {
        this.discount = discount;
    }
}
```

------

# 依赖倒置到底 “倒置” 了什么？

### 原来的依赖方向（正常、错误）

订单服务 → 依赖 → 优惠券

### 倒置后的方向（正确）

优惠券 → 实现 → 抽象

订单服务 → 依赖 → 抽象

**依赖关系反过来了！**

- 不是高层追着底层跑
- 是底层来适配高层的抽象

这就叫 **依赖倒置**。

------

# 最通俗的三句总结

1. **高层不要直接依赖底层具体实现**
2. **大家都依赖抽象（接口）**
3. **细节去实现抽象，而不是高层去依赖细节**

------

# 你只要记住一句口诀

**依赖抽象，不依赖具体。**

这就是依赖倒置。



## 其他解释


# 1）没使用依赖倒置：正常方向（耦合死）

```
订单服务（高层）
       ↓ 依赖
优惠券（底层）
```

- 箭头：**高层 → 底层**
- 特点：高层死死依赖底层
- 后果：换优惠方式 = 改订单代码

------

# 2）使用依赖倒置：方向反过来了！

```
优惠券  → 实现 →  抽象接口（Discount）
                         ↑ 依赖
                  订单服务（高层）
```

现在依赖方向变成：



```
底层 → 抽象 ← 高层
```

**这就叫：依赖关系倒置了。**

------

# 3）一句话看懂 “倒置”

- 以前：**高层依赖底层**
- 现在：**底层依赖抽象，高层也依赖抽象**
- 箭头方向**反过来**了 → 所以叫 **依赖倒置**

------

# 4）最直观的电商比喻

高层 = 老板（订单）

底层 = 员工（优惠券、满减、折扣）

- **没倒置：老板听员工的**

  员工变了，老板就得跟着变。



- **倒置后：员工听老板的**

  老板定规矩（接口），员工来遵守。



------

# 5）Java 里一眼识别依赖倒置

看到这 3 条，就是依赖倒置：

1. 有 **接口**
2. 具体类 **implements 接口**
3. 高层类 **持有接口**，不 new 具体类


```
// 接口（抽象）
interface Discount {}

// 底层依赖抽象
class Coupon implements Discount {}

// 高层也依赖抽象
class OrderService {
    private Discount discount; // 接口！
}
```