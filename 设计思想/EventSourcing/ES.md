# Event Sourcing（事件溯源）详解

Event Sourcing，简称**ES**，中文译为**事件溯源**，是一种以**领域事件为核心**的架构设计模式与数据存储范式。其核心思想与会计复式记账法完全一致：**不直接存储系统的当前状态，而是持久化所有导致状态变化的、不可变的业务领域事件；系统的当前状态，始终通过完整重放该对象的历史事件序列计算派生而来**。

它彻底颠覆了传统 CRUD 架构 “直接修改覆盖状态” 的模式，将 “已经发生的业务事实” 作为系统唯一的可信数据源，当前状态只是事件的派生产物，天然适配 DDD 领域驱动设计，且与 CQRS 模式是工业界公认的黄金搭档，广泛应用于金融、交易、供应链等复杂业务系统。

------

## 一、核心本质：与传统 CRUD 的根本区别

用最直观的对比，讲清 ES 和传统状态存储的核心差异：


| 对比维度     | 传统 CRUD 状态存储                                         | 事件溯源（ES）                                         |
| ------------ | ---------------------------------------------------------- | ------------------------------------------------------ |
| 存储核心     | 系统的**当前状态快照**                                     | 所有导致状态变化的**领域事件序列**                     |
| 数据操作     | 可变，支持 UPDATE/DELETE 覆盖 / 删除历史                   | 不可变，仅支持 APPEND 追加写入，绝不修改已持久化的事件 |
| 状态获取方式 | 直接读取存储的当前状态值                                   | 重放对应聚合的全量历史事件，计算得到当前状态           |
| 业务语义     | 技术化的增删改操作，丢失业务意图（仅知结果，不知为何修改） | 事件直接表达业务事实，完整保留业务意图与操作上下文     |
| 审计追溯能力 | 需额外开发审计日志，易出现日志与状态不一致                 | 天然自带完整、不可篡改的审计链路，事件本身就是审计记录 |
| 并发控制     | 基于状态字段的乐观锁 / 悲观锁                              | 基于聚合版本号的乐观并发控制，杜绝状态冲突             |
| 历史回溯能力 | 仅能查看当前状态，历史状态需额外存储                       | 可回溯任意时间点的状态，可重放事件重建任意历史版本     |

------

## 二、核心概念定义

### 1. 领域事件（Domain Event）

领域事件是 ES 的核心，它是**对业务中已经发生的、不可逆转的、对业务有明确意义的事实的原子性记录**。

- 核心特性：

    - 不可变性：事件一旦持久化，绝不修改、删除，业务错误只能通过**补偿事件**修正；
    - 时序性：事件有严格的发生顺序，对应聚合的版本号递增；
    - 事实性：只记录 “已经发生的事”，不记录 “将要做的事”；
    - 业务语义：事件名必须是业务术语（如`订单已创建`、`订单已支付`），而非技术术语（如`order表已更新`）；
    - 自包含：事件必须包含完整的业务上下文，无需依赖外部数据即可重放。



### 2. 聚合根（Aggregate Root）

ES 中，事件的组织单位是 DDD 中的聚合根。每个聚合根对应一个独立的事件序列，聚合的当前状态，仅由自身的事件序列重放生成，保证事务边界与数据一致性。

- 示例：订单聚合根，对应`订单已创建`、`订单已支付`等完整事件序列，订单的当前状态完全由这些事件计算而来。

### 3. 事件存储（Event Store）

专门用于持久化领域事件的存储组件，是 ES 的核心基础设施。

- 核心要求：必须保证事件的**原子追加、有序性、不可变性、幂等性**；
- 核心字段：聚合 ID、事件类型、事件数据（JSON / 二进制）、聚合版本号、事件发生时间戳、唯一事件 ID；
- 常见实现：专用事件数据库（EventStoreDB）、关系型数据库（MySQL/PostgreSQL 事件表）、分布式日志系统（Kafka）。

### 4. 快照（Snapshot）

为解决事件序列过长导致的重放性能问题，引入的优化机制。

- 核心逻辑：当聚合的事件数量达到阈值（如每 100 个事件），持久化一次该聚合的当前状态快照；后续获取状态时，直接读取最新快照，仅重放快照之后的事件，无需从头遍历全量事件，大幅提升性能。

### 5. 补偿事件（Compensation Event）

用于修正业务错误的特殊事件。由于 ES 中事件不可变，无法修改 / 删除已写入的错误事件，只能通过追加补偿事件，抵消错误事件的业务影响，保证业务最终正确性。

- 示例：错误的`订单已支付`事件，不能删除，需追加`订单支付已撤销`的补偿事件。

------

## 三、ES 核心原则

1. **事件唯一事实源原则**

   领域事件是系统唯一的可信数据源，所有业务状态、统计数据、读模型，都必须由事件派生而来，绝不允许绕过事件直接修改状态。



2. **事件不可变原则**

   事件一旦持久化到事件存储，就代表已经发生的业务事实，绝对禁止修改、删除、回溯，保证数据的完整性与可审计性。



3. **状态派生原则**

   聚合的当前状态，只能通过重放自身的事件序列计算得到，不能直接存储和修改，杜绝状态与事件不一致的问题。



4. **单聚合一事务原则**

   一次事务只能追加一个聚合根的事件序列，保证事务边界清晰，避免分布式事务问题，确保事件的原子性与一致性。



5. **乐观并发原则**

   基于聚合版本号做并发控制：每次追加事件时，校验当前聚合的版本号是否与预期一致，不一致则说明有并发修改，拒绝写入，保证事件时序的正确性。



------

## 四、完整工作流程

以电商订单创建为例，ES 的完整执行流程如下：

1. **接收业务命令**：系统接收`创建订单`的业务命令，包含用户 ID、商品、金额等参数。
2. **加载聚合状态**：根据订单聚合 ID，从事件存储加载该聚合的历史事件（或快照），重放得到聚合的当前状态。
3. **业务规则校验**：在聚合内执行业务规则校验（如商品库存、用户权限、金额合法性等）。
4. **生成领域事件**：校验通过后，聚合生成`订单已创建`的领域事件，包含完整的业务上下文。
5. **持久化事件**：将事件原子追加到事件存储，同时递增聚合的版本号，完成写事务。
6. **发布事件**：事件持久化成功后，将事件发布到事件总线，供下游消费。
7. **更新读模型（CQRS 协同）**：下游消费事件，更新 CQRS 的读模型（如订单列表、订单详情视图），供查询操作使用。
8. **状态获取**：当需要获取订单当前状态时，重放该订单的所有事件，计算得到最新状态。

------

## 五、与 CQRS 的黄金协同

ES 与 CQRS 是互补的架构模式，而非替代关系，二者结合可以完美解决彼此的短板，是复杂业务系统的经典架构组合：

### 1. 核心互补关系

- **CQRS 解决 ES 的查询痛点**：ES 本身不擅长快速查询（重放事件获取状态性能低），而 CQRS 的读模型，通过订阅事件提前预计算并持久化查询所需的视图数据，查询直接访问读模型，无需重放事件，彻底解决 ES 的查询性能问题。
- **ES 解决 CQRS 的写模型与数据同步痛点**：CQRS 的写模型需要处理复杂业务规则与状态变更，ES 天然适配 DDD 的聚合设计，将业务规则收敛到聚合内，通过事件统一管理状态变更；同时，事件作为 CQRS 读写两侧的同步媒介，天然解决了读写模型的数据同步问题，保证数据一致性。

### 2. 经典组合架构




```
用户请求 → 命令网关 → 命令处理器 → 聚合根（ES写模型）→ 事件存储 → 事件总线
                                                                 ↓
查询请求 ← 读模型视图 ← 事件消费者 ←———————————————————————————
```

- 写侧：完全基于 ES 实现，只负责处理命令、生成事件、持久化事件，不处理任何查询逻辑；
- 读侧：完全基于事件构建，只负责处理查询，不修改任何数据，按需定制读模型，极致优化查询性能。

------

## 六、核心优缺点

### 核心优势

1. **天然完整的审计与追溯能力**：事件序列完整记录了所有业务操作，不可篡改，满足金融、支付等行业的合规审计要求，可回溯任意时间点的业务状态，定位问题无需额外日志。
2. **完整保留业务意图**：事件直接表达业务事实，而非技术化的状态修改，代码与业务语义完全对齐，大幅提升复杂业务的可维护性。
3. **完美适配 DDD 与事件驱动架构**：ES 的聚合、事件与 DDD 的核心概念完全契合，天然支持事件驱动、微服务解耦，服务间通过事件通信，无强耦合。
4. **超强的业务灵活性**：当业务新增查询需求、统计维度时，无需修改历史数据，只需重放全量事件，即可生成全新的读模型与统计数据，应对需求变化的能力极强。
5. **优秀的并发写性能**：事件存储仅做追加写入，无 UPDATE/DELETE 操作，数据库锁冲突极少，写入性能远高于传统状态更新模式，适配高并发写场景。
6. **轻松实现状态回滚与重建**：无需备份恢复，通过重放 / 跳过指定事件，即可回滚到任意历史状态，或重建聚合的完整状态。

### 核心劣势与挑战

1. **极高的学习与落地门槛**：ES 颠覆了传统 CRUD 的开发思维，团队需要深入理解 DDD、领域事件、事件驱动架构，否则极易落地失败，造成架构混乱。
2. **系统复杂度大幅提升**：需要维护事件存储、快照机制、事件版本兼容、事件同步、读模型更新等组件，开发、测试、运维成本远高于传统架构。
3. **最终一致性挑战**：ES 与 CQRS 结合时，读模型是异步更新的，只能保证最终一致性，需要业务层面适配数据延迟的场景，无法满足强一致性查询需求。
4. **事件版本兼容难题**：业务迭代会导致事件结构变化，需要处理历史事件的版本兼容问题，否则会导致事件重放失败，是 ES 落地的核心难点之一。
5. **存储成本高**：所有事件永久存储，不可删除，数据量会持续增长，尤其高频操作的系统，存储成本远高于传统模式。
6. **合规性挑战**：面对 GDPR 等要求用户数据硬删除的合规场景，事件不可变的特性会导致合规处理难度极大，只能通过数据脱敏、加密、补偿事件等方式适配。
7. **调试与问题排查难度高**：业务状态由事件重放生成，问题排查需要追溯完整的事件序列，比传统直接查看状态的模式复杂得多。

------

## 七、适用与不适用场景

### 强烈推荐的适用场景

1. 金融、支付、证券、保险等对审计追溯、合规性有强要求的系统；
2. 业务规则复杂、领域逻辑丰富的系统，如电商交易、供应链、订单管理、合同管理等，适配 DDD 架构落地；
3. 高并发写、读写流量差异大的系统，如秒杀、交易系统，可充分发挥 ES 追加写入的性能优势；
4. 需要完整历史回溯、状态重建、多维度统计的业务系统；
5. 微服务架构下，需要通过事件驱动实现服务解耦的系统。

### 绝对不推荐的场景

1. 简单 CRUD 业务，无复杂领域逻辑、无审计追溯需求的系统，如简单的后台管理系统，会造成严重的过度设计；
2. 对数据强一致性有极致要求，无法接受最终一致性的核心场景；
3. 团队规模小、技术能力不足，无法驾驭架构复杂度的项目；
4. 需要频繁硬删除数据的业务，无法适配事件不可变的核心原则；
5. 业务需求频繁变更，且事件结构无法稳定的系统，会导致版本兼容成本极高。

------

## 八、常见误区纠正

1. **误区 1：事件溯源就是存操作日志**

   纠正：二者有本质区别。普通操作日志是技术层面的辅助记录，不是系统的数据源；而 ES 的领域事件是系统唯一的事实源，状态完全由事件派生，日志是附属品，事件是核心。



2. **误区 2：ES 必须和 CQRS 一起使用**

   纠正：ES 可以独立使用，二者没有强绑定。但独立使用 ES 时，查询性能问题很难解决，因此工业界几乎都是 ES+CQRS 组合落地，二者互补，而非必须。



3. **误区 3：ES 里的事件可以修改 / 删除**

   纠正：事件不可变是 ES 的核心原则，已经发生的业务事实无法修改，业务错误只能通过追加补偿事件修正，任何修改 / 删除事件的行为，都违背了 ES 的核心思想。



4. **误区 4：ES 每次查询都要全量重放事件**

   纠正：工业界落地时，都会通过**快照机制**优化重放性能，同时配合 CQRS 的读模型，查询直接访问预计算的读视图，完全不需要重放事件，只有写侧处理命令时，才会重放事件加载聚合状态。



5. **误区 5：ES 就是一种数据库技术**

   纠正：ES 是一种架构设计范式与数据建模思想，不是某种特定的数据库或中间件。它可以基于关系型数据库、专用事件数据库、甚至分布式日志系统实现，核心是思想，而非技术组件。



------

## 九、极简落地示例（订单场景）

### 1. 领域事件序列（订单聚合 ID：123）



| 事件 ID | 事件类型   | 事件核心内容                                            | 聚合版本号 | 发生时间         |
| ------- | ---------- | ------------------------------------------------------- | ---------- | ---------------- |
| 001     | 订单已创建 | 订单 ID:123，用户 ID:456，商品 ID:789，订单金额：100 元 | 1          | 2026-02-21 10:00 |
| 002     | 订单已支付 | 订单 ID:123，支付金额：100 元，支付渠道：微信           | 2          | 2026-02-21 10:05 |
| 003     | 订单已发货 | 订单 ID:123，物流单号：SF123456，快递公司：顺丰         | 3          | 2026-02-21 14:00 |
| 004     | 订单已完成 | 订单 ID:123，确认收货时间：2026-02-22 18:00             | 4          | 2026-02-22 18:00 |

### 2. 状态重放逻辑

- 重放事件 001：订单状态 = 待支付，金额 = 100 元
- 重放事件 002：订单状态 = 待发货，支付状态 = 已支付
- 重放事件 003：订单状态 = 待收货，物流状态 = 已发货
- 重放事件 004：订单状态 = 已完成，交易状态 = 已完结

最终得到订单的当前状态，同时完整保留了整个订单生命周期的业务轨迹与审计链路。